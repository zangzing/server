# this class tracks any zz api error condition set
class ZZAPIError < StandardError
  attr_reader :result, :code

  # error codes
  unless defined?(INVALID_LIST_ARGS)
    INVALID_LIST_ARGS     = 1001
  end

  # the message here can be a string, array or hash, or ActiveModel Error
  # for consistency you should generally use a single string,
  # an array of strings or as last resort a custom hash
  def initialize(result, code = 409)
    if result.is_a?(ActiveModel::Errors)
      @result = result.full_messages
    else
      @result = result
    end
    @code = code
  end

  def to_s
    if @result.is_a?(String)
      @result
    else
      super
    end
  end
end

class ZZAPIInvalidListError < ZZAPIError
  # expects you to pass a set of key names as
  # ['key1', 'key2', ...]
  # and a set of missing value lists
  # in the form generated by build_missing_item
  # and will result in an exception containing
  # a result of:
  # {
  #   key1 => [
  #     {
  #       :index => the index in the corresponding input list location,
  #       :token => the missing value such as email or group_id,
  #       :error => an error string, may be blank
  #     }
  #     ...
  #   ],
  #   ...
  # }
  #
  def initialize(items, code = INVALID_LIST_ARGS)
    super(items, code)
  end

  def self.build_missing_item(index, token, error = 'Not Found')
    { :index => index, :token => token, :error => error }
  end

  # a helper to build a standard error
  # entry for a missing item in a list
  # pass it the expected list, found_set
  # and it will build a list of missing items
  # in the form
  #
  def self.build_missing_list(expected, found)
    list = []
    index = 0
    expected.each do |item|
      list << build_missing_item(index, item) unless found.include?(item)
      index += 1
    end
    list
  end


end

#begin
#  raise ZZAPIError.new({:test=>"data", :arr=>[1,2,3]})
#rescue ZZAPIError => ex
#  ex.message
#  ex.to_s
#  puts ex.result.to_s
#  puts ex.code
#end